<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="mobile-web-app-capable" content="yes" />
  <title>Brainrot Battle</title>
  <link rel="manifest" href="manifest.json" />
  <link rel="icon" href="icon-192.png" type="image/png" />
  <link href="https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap" rel="stylesheet">
  <style>
    :root {
      --card-width: 22vw;
      --card-height: calc(var(--card-width) * 1.4);
      --hand-height: calc(var(--card-height) * 0.8);
    }
    
    * {
      box-sizing: border-box;
      touch-action: manipulation;
    }
    
    body {
      font-family: 'Fredoka One', cursive;
      background-image:url("img/hq720_2.jpg");

      color: #fff;
      margin: 0;
      padding: 0;
      overflow: hidden;
      width: 100vw;
      height: 100vh;
      display: flex;
      flex-direction: column;
      position: fixed;
    
    }
    
    .game-container {
      flex: 1;
      display: flex;
      flex-direction: column;
      width: 100%;
      height: calc(100% - 50px);
      margin: 0 auto;
      max-width: 500px;
      position: relative;
    }
    
    .ui-bar {
      display: flex;
      justify-content: space-between;
      width: 100%;
      padding: 8px 10px;
      background: #45b3f3a6;
      font-size: 14px;
      flex-shrink: 0;
    }
    
    .turn-indicator {
      text-align: center;
      padding: 5px;
      font-weight: bold;
      background: #333;
      font-size: 14px;
      flex-shrink: 0;
    }
    
    .player-turn {
      background: #4CAF50;
    }
    
    .enemy-turn {
      background: #F44336;
    }
    
    .board {
      flex: 1;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      padding: 5px 0;
      overflow: hidden;
    }
    
    .zone {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 8px;
      padding: 0 8px;
      min-height: calc(var(--card-height) + 10px);
      place-items: center; /* Ajout pour centrer les slots */
      justify-content: center; /* Centre horizontalement */
    }
    
    .slot {
      background: #d0ecff85;
      border: 2px solid transparent;
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      aspect-ratio: 2/3;
      position: relative;
      transition: all 0.2s;
      height: var(--card-height);
    }
    
    .slot.ally { border-color: #4CAF50; }
    .slot.enemy { border-color: #F44336; }
    .slot.highlight { 
      border: 3px solid #FFEB3B;
      box-shadow: 0 0 10px #FFEB3B;
    }
    .slot.attackable {
      border: 3px solid #F44336;
      box-shadow: 0 0 10px #F44336;
    }
    .slot.placeable {
      border: 3px solid #2196F3;
      box-shadow: 0 0 10px #2196F3;
    }
    
    .card {
      background: linear-gradient(135deg, #444 0%, #333 100%);
      border: 2px solid #fff;
      border-radius: 8px;
      padding: 8px;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      font-size: 12px;
      text-align: center;
      box-shadow: 0 3px 6px rgba(0,0,0,0.3);
      position: relative;
      overflow: hidden;
    }
    
    .card::before {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 5px;
      background: linear-gradient(90deg, #FF5722, #FFC107);
    }
    
    .card-name {
      font-weight: bold;
      font-size: 14px;
      margin-bottom: 5px;
      color: #FFC107;
    }
    
    .card-stats {
      display: flex;
      justify-content: space-around;
      margin: 5px 0;
    }
    
    .card-stat {
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    
    .card-stat-value {
      font-weight: bold;
      font-size: 16px;
    }
    
.card-effect {
  font-size: 10px;
  color: #BDBDBD;
  margin-top: 5px;
  overflow: hidden;
  text-overflow: ellipsis;
  display: -webkit-box;
  -webkit-line-clamp: 2;
  line-clamp: 2; /* <- Add this line */
  -webkit-box-orient: vertical;
}

    
    .mana-cost {
      position: absolute;
      top: 5px;
      right: 5px;
      background: #2196F3;
      color: white;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      font-size: 12px;
    }
    

.ultimate-progress {
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  height: 5px;
  background: #333;
  border-radius: 0 0 6px 6px;
  z-index: 2;
}

.ultimate-progress-fill {
  height: 100%;
  background: linear-gradient(90deg, #9C27B0, #E91E63);
  border-radius: 0 0 6px 6px;
  transition: width 0.3s ease;
}
    .hand-container {
      height: var(--hand-height);
      width: 100%;
      position: relative;
      flex-shrink: 0;
    }
    
    .hand {
      display: flex;
      gap: 8px;
      padding: 0 8px;
      width: 100%;
      height: 100%;
      overflow-x: auto;
      scroll-snap-type: x mandatory;
      scrollbar-width: none;
    }
    
    .hand::-webkit-scrollbar {
      display: none;
    }
    
    .hand-card {
      scroll-snap-align: center;
      flex: 0 0 calc(var(--card-width) * 0.8);
      height: calc(var(--hand-height) - 10px);
    }
    
    .controls {
      display: flex;
      justify-content: space-between;
      width: 100%;
      padding: 8px;
      background: #001f2aae;
      flex-shrink: 0;
    }
    
    .btn {
      padding: 8px 12px;
      border: none;
      border-radius: 5px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.2s;
      font-size: 14px;
    }
    
    .btn-primary {
      background: #4CAF50;
      color: white;
    }
    
    .btn-primary:hover {
      background: #45a049;
    }
    
    .btn-secondary {
      background: #2196F3;
      color: white;
    }
    
    .btn-secondary:hover {
      background: #0b7dda;
    }
    
    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    /* Affichage des d√©tails de la carte s√©lectionn√©e */
    .card-details {
      position: absolute;
      top: 50px;
      left: 0;
      right: 0;
      background: rgba(65, 126, 187, 0.9);
      padding: 10px;
      z-index: 50;
      border-bottom: 2px solid #FFC107;
      display: none;
    }
    
    .card-details.active {
      display: block;
    }
    
    .card-details-name {
      font-weight: bold;
      font-size: 16px;
      color: #FFC107;
      margin-bottom: 5px;
      text-align: center;
    }
    
    .card-details-stats {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin-bottom: 5px;
    }
    
    .card-details-stat {
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    
    .card-details-stat-value {
      font-weight: bold;
      font-size: 18px;
    }
    
    .card-details-effect {
      font-size: 12px;
      text-align: center;
      margin-bottom: 5px;
    }
    
    .position-effects {
      display: flex;
      justify-content: space-between;
      margin-top: 10px;
    }
    
    .position-effect {
      flex: 0 0 48%;
      padding: 8px;
      background: rgba(0,0,0,0.3);
      border-radius: 8px;
      font-size: 12px;
    }
    
    .position-effect h4 {
      margin: 0 0 5px 0;
      color: #FFC107;
      font-size: 14px;
    }
    


    .ultimate-details {
      display: flex;
      justify-content: space-between;
      margin-top: 10px;
    }
    
    .ultimate-details {
      flex: 0 0 48%;
      padding: 8px;
      background: rgba(0,0,0,0.3);
      border-radius: 8px;
      font-size: 12px;
    }
    
    .ultimate-details h4 {
      margin: 0 0 5px 0;
      color: #c144ff;
      font-size: 14px;
    }
    .position-effect.front h4::before {
      content: "üõ°Ô∏è ";
    }
    
    .position-effect.back h4::before {
      content: "üèπ ";
    }
    
    .selected-card {
      box-shadow: 0 0 15px #FFEB3B;
      transform: scale(1.05);
    }
    
    /* Animation d'attaque */
    .attack-animation {
      position: absolute;
      width: 50px;
      height: 50px;
      background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="%23FF5722"><path d="M12 2L4 12l8 10 8-10z"/></svg>') no-repeat center;
      background-size: contain;
      animation: attackMove 0.5s forwards;
      z-index: 100;
      pointer-events: none;
    }
    
    @keyframes attackMove {
      0% { transform: scale(0.5); opacity: 0; }
      50% { transform: scale(1.2); opacity: 1; }
      100% { transform: scale(0.5); opacity: 0; }
    }
    
    @media (min-width: 600px) {
      :root {
        --card-width: 18vw;
      }
      
      .zone {
        grid-template-columns: repeat(4, 1fr);
      }
      
      .slot:nth-child(1), .slot:nth-child(2) {
        grid-row: 1;
      }
      
      .slot:nth-child(3), .slot:nth-child(4) {
        grid-row: 2;
      }
      
      .card-name {
        font-size: 16px;
      }
      
      .card-stat-value {
        font-size: 18px;
      }
      
      .card-effect {
        font-size: 12px;
      }
    }
    
    @media (max-width: 400px) {
      :root {
        --card-width: 24vw;
      }
      
      .card-name, .card-details-name {
        font-size: 12px;
      }
      
      .card-stat-value, .card-details-stat-value {
        font-size: 14px;
      }
      
      .card-effect, .card-details-effect {
        font-size: 10px;
      }
      
      .btn {
        padding: 6px 10px;
        font-size: 12px;
      }
    }

    
    .selected-card {
      border: 3px solid #FFEB3B;
      box-shadow: 0 0 15px #FFEB3B;
      transform: scale(1.1);
      transition: all 0.2s;
      z-index: 10;
    }

    .playable-card {
      border: 2px solid #4CAF50;
      box-shadow: 0 0 10px #4CAF50;
    }

    .attackable-player {
      border: 3px solid #F44336 !important;
      box-shadow: 0 0 15px #F44336 !important;
   
    }



    .used-card {
      opacity: 0.6;
      filter: grayscale(50%);
    }

    
    .selected-board-card {
      border: 3px solid #FF9800;
      box-shadow: 0 0 15px #FF9800;
      transform: scale(1.05);
      z-index: 10;
    }

    .unusable-card {
      opacity: 0.6;
      filter: grayscale(70%);
      cursor: not-allowed;
    }

    .attackable {
      border: 3px solid #F44336 !important;
      box-shadow: 0 0 15px #F44336 !important;
      animation: pulse 1s infinite;
    }

    .attack-animation {
  position: absolute;
  width: 50px;
  height: 50px;
  background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="%23FF5722"><path d="M12 2L4 12l8 10 8-10z"/></svg>') no-repeat center;
  background-size: contain;
  animation: attackMove 0.5s forwards;
  z-index: 100;
  pointer-events: none;
  transform-origin: center;
}

@keyframes attackMove {
  0% { transform: translate(0, 0) scale(0.5); opacity: 0; }
  50% { transform: translate(var(--tx), var(--ty)) scale(1.2); opacity: 1; }
  100% { transform: translate(var(--tx), var(--ty)) scale(0.5); opacity: 0; }
}

.slot.attackable {
  border: 3px solid #F44336 !important;
  box-shadow: 0 0 15px #F44336 !important;
  animation: pulse 1s infinite;
  cursor: pointer;
}

#enemy-hp.attackable-player {
  border: 3px solid #F44336 !important;
  box-shadow: 0 0 15px #F44336 !important;
  animation: pulse 1s infinite;
}

/* Animation de stabilisation des cartes */
.card {
  transition: transform 0.3s ease, opacity 0.3s ease;
}

.card-destroyed {
  transform: scale(0);
  opacity: 0;
  transition: all 0.5s ease;
}

/* Garder les cartes ennemies stables */
.enemy-zone .card {
  pointer-events: none; /* Emp√™cher l'interaction directe */
}

/* Ajoutez dans le style */
.btn-ultimate {
  background: #9C27B0;
  color: white;
}

.btn-ultimate:hover {
  background: #7B1FA2;
}

.card-ready-for-ultimate {
  border: 3px solid #2196F3;
  box-shadow: 0 0 15px #2196F3;
  animation: pulse-blue 1s infinite;
}

@keyframes pulse-blue {
  0% { box-shadow: 0 0 5px #2196F3; }
  50% { box-shadow: 0 0 20px #2196F3; }
  100% { box-shadow: 0 0 5px #2196F3; }
}

.card {
  position: relative;
  padding-bottom: 8px; /* Espace pour la barre d'ulti */
}

@media (max-width: 600px) {
  .card {
    background-size: contain;
    background-repeat: no-repeat;
  }
  
  .card-content {
    background: rgba(0, 0, 0, 0.8);
  }
}



.card-content {
  position: relative;
  z-index: 2; /* Place le contenu au-dessus de l'image de fond */
  background: rgba(0, 0, 0, 0.6); /* Fond semi-transparent pour le texte */
  height: 100%;
  padding: 8px;
  display: flex;
  flex-direction: column;
}

.card::before {
  content: "";
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 5px;
  background: linear-gradient(90deg, #FF5722, #FFC107);
  z-index: 3;
}
.ios-safe-area {
  display: none;
}


  </style>
</head>
<body>
  <div class="turn-indicator player-turn" id="turn-indicator">VOTRE TOUR</div>
  
  <div class="card-details" id="card-details"></div>
  
  <div class="ui-bar">
    <div>Ennemi: <span id="enemy-hp">20</span> ‚ù§Ô∏è</div>
    <div>Mana: <span id="enemy-mana">1</span>/10 ‚ú®</div>
  </div>

  <div class="game-container">
    <div class="board">
      <div class="zone enemy-zone" id="enemy-zone"></div>
      <div class="zone player-zone" id="player-zone"></div>
    </div>
    
    <div class="hand-container">
      <div class="hand" id="hand"></div>
    </div>
  </div>
  
  <div class="ui-bar">
    <div>Vous: <span id="player-hp">20</span> ‚ù§Ô∏è</div>
    <div>Mana: <span id="player-mana">1</span>/10 ‚ú®</div>
  </div>

 
    <div class="controls">
      <button class="btn btn-secondary" id="draw-btn" onclick="drawCard()">Piocher (3‚ú®)</button>
      <button class="btn btn-ultimate" id="ultimate-btn" onclick="useUltimate()" disabled>Ulti (2‚ú®)</button>
      <button class="btn btn-primary" id="end-turn-btn" onclick="endTurn()">Fin du tour</button>
    </div>
    <div class="controls">
     
    </div>



  <script>
    // √âtat du jeu
    const gameState = {
      player: { 
        hp: 20, 
        mana: 1, 
        maxMana: 1, 
        deck: [], 
        hand: [], 
        board: Array(4).fill(null),
        selectedCard: null,
        selectedAttacker: null,
        exhaustedCards: [] // Cartes qui ont d√©j√† attaqu√© ce tour
      },
      enemy: { 
        hp: 20, 
        mana: 1, 
        maxMana: 1, 
        board: Array(4).fill(null),
        exhaustedCards: [] // Cartes qui ont d√©j√† attaqu√© ce tour
      },
      turn: 'player',
      canPlayCards: true,
      ultimateReady: null // Index de la carte pr√™te √† ulti
    };

    // Biblioth√®que de cartes
    const cardsLibrary = [
      { 
        id: 1,
        name: "Bombardino Crocodillo", 
        hp: 5, 
        atk: 3, 
        cost: 3, 
        effect: " un fottuto alligatore volante",
        bgImage: "url('img/bombardino.png')",
        frontEffect: "Attaque l'ennemi avec 3 ATK",
        backEffect: "Donne +1 ATK √† toutes vos autres cr√©atures",
        frontLogic: (attacker, target) => basicAttack(attacker, target),
        backLogic: (card, board) => buffAllies(board, 1, 0),
        ultimate: {
    cost: 2, // Co√ªt en mana
    turnsNeeded: 3, // Tours n√©cessaires avant activation
    effect: "Inflige 1 d√©g√¢t √† tous les adversaires",
    execute: (card, board) => {
      gameState.enemy.board.forEach(c => c && (c.hp -= 1));
      gameState.enemy.hp -= 1;
    }
  }
      },
      { 
        id: 2,
        name: "Liril√¨ Laril√†", 
        hp: 2, 
        atk: 2, 
        cost: 2, 
        effect: "elefante nel deserto che cammina qua e l√†",
        bgImage: "url('img/Lirili_rili_ralila.webp')",
        frontEffect: "Inflige 2 d√©g√¢ts et pioche 1 carte",
        backEffect: "Soigne 1 PV √† votre joueur",
        frontLogic: (attacker, target) => {
          basicAttack(attacker, target);
          if (gameState.player.hand.length < 5) {
            drawCardToHand();
          }
        },
        backLogic: (card, board) => healPlayer(1)
      },
      { 
        id: 3,
        name: "Trippi Troppi", 
        hp: 1, 
        atk: 1, 
        cost: 1, 
        effect: "Trippi troppi, troppa trippa, tre topi trotterellano tra tromboni tritati",
        bgImage: "url('img/640.webp')",
        frontEffect: "Effet al√©atoire: attaque, soin ou buff",
        backEffect: "Effet al√©atoire: soin, buff ou d√©g√¢ts",
        frontLogic: (attacker, target) => {
          const effects = [
            () => basicAttack(attacker, target),
            () => healPlayer(1),
            () => buffCard(attacker, 1, 1)
          ];
          effects[Math.floor(Math.random() * effects.length)]();
        },
        backLogic: (card, board) => {
          const effects = [
            () => healPlayer(1),
            () => buffAllies(board, 0, 1),
            () => damageEnemy(1)
          ];
          effects[Math.floor(Math.random() * effects.length)]();
        }
      },
      {
        id: 4,
        name: "Tralalero Tralala", 
        hp: 3, 
        atk: 2, 
        cost: 4, 
        effect: "Trallallero Trallalla, porco dio porco allah",
        bgImage: "url('img/Tralalero_tralala.webp')",
        frontEffect: "Inflige 1 d√©g√¢t √† toutes les cartes ennemies",
        backEffect: "Soigne 1 PV √† toutes vos cartes",
        frontLogic: (attacker, target) => {
          gameState.enemy.board.forEach(card => {
            if (card) card.hp -= 1;
          });
        },
        backLogic: (card, board) => {
          board.forEach(card => {
            if (card) card.hp = Math.min(card.hp + 1, card.hp + 5); // +5 est le HP de base
          });
        }
      },

  
  { 
    id: 5,
    name: "Brr brr Patapim", 
    hp: 6, 
    atk: 1, 
    cost: 2, 
    effect: "il mio cappello √® pieno di Slim! Nel bosco fitto e misterioso viveva un essere assai curioso.",
    bgImage: "url('img/Brr_Brr_Patapim.webp')",
    frontEffect: "Bloque 1 d√©g√¢t re√ßu par les autres cartes",
    backEffect: "Soigne 1 PV √† une carte al√©atoire √† la fin du tour",
    frontLogic: (attacker, target) => basicAttack(attacker, target),
    backLogic: (card, board) => {
      const aliveCards = board.filter(c => c && c.hp > 0);
      if (aliveCards.length > 0) {
        const randomCard = aliveCards[Math.floor(Math.random() * aliveCards.length)];
        randomCard.hp += 1;
      }
    },
    ultimate: {
      cost: 1,
      turnsNeeded: 2,
      effect: "Soigne 2 PV √† toutes vos cartes",
      execute: (card, board) => board.forEach(c => c && (c.hp += 2))
    }
  },

  { 
    id: 6,
    name: "Frulli Frulla", 
    hp: 2, 
    atk: 4, 
    cost: 4, 
    effect: "Frulli Frulla",
    frontEffect: "Attaque deux fois mais ne peut pas attaquer le tour o√π il est pos√©",
    bgImage: "url('img/Frulli_Frulla.webp')",
    backEffect: "Attaque une fois par tour",
    frontLogic: (attacker, target) => {
      basicAttack(attacker, target);
      setTimeout(() => basicAttack(attacker, target), 300);
    },
    backLogic: (card, board) => {}, // Pas d'effet en position arri√®re
    ultimate: {
      cost: 3,
      turnsNeeded: 1,
      effect: "Inflige 5 d√©g√¢ts √† une cible al√©atoire",
      execute: (card, board) => {
        const targets = [...gameState.enemy.board.filter(c => c), {hp: gameState.enemy.hp}];
        const target = targets[Math.floor(Math.random() * targets.length)];
        target.hp -= 5;
      }
    }
  },

  { 
    id: 7,
    name: "Bobritto bandito", 
    hp: 1, 
    atk: 1, 
    cost: 1, 
    effect: "Bobritto Bandito is a beaver bandit with a black jacket, black glasses and a hat.",
    bgImage: "url('img/Bomborito_bandito.webp')",
    frontEffect: "R√©v√®le une carte ennemie al√©atoire (montre ses PV/ATK)",
    backEffect: "Pioche 1 carte suppl√©mentaire si survit au tour",
    frontLogic: (attacker, target) => {
      // Effet visuel uniquement (serait √† impl√©menter dans l'UI)
      basicAttack(attacker, target);
    },
    backLogic: (card, board) => {
      if (gameState.player.hand.length < 5) {
        drawCardToHand();
      }
    }
  },

  { 
    id: 8,
    name: "Glorbo Fruttodrillo", 
    hp: 8, 
    atk: 0, 
    cost: 3, 
    effect: "glorbo fruttodrillo nel profondo della Palude glorbo frutt drillo regnava il suo corpo era un'enorme anguria a strisce ",
    bgImage: "url('img/Glorbofruttodrillo.webp')",
    frontEffect: "R√©duit de 1 les d√©g√¢ts re√ßus par vos autres cartes",
    backEffect: "Gagne +2 HP √† la fin du tour",
    frontLogic: (attacker, target) => {}, // Effet passif
    backLogic: (card, board) => card.hp += 2
  },

  { 
    id: 9,
    name: "Tung tung tung sahur", 
    hp: 3, 
    atk: 5, 
    cost: 5, 
    effect: "Tung tung tung tung sahur. Anomali mengerikan yang hanya keluar pada sahur. ",
    bgImage: "url('img/Anomali_tung_tung_tung.png')",
    frontEffect: "50% de chance d'attaquer deux fois, 50% de rater",
    backEffect: "Inflige 1 d√©g√¢t √† une cible al√©atoire √† la fin du tour",
    frontLogic: (attacker, target) => {
      if (Math.random() > 0.5) {
        basicAttack(attacker, target);
        setTimeout(() => basicAttack(attacker, target), 300);
      }
    },
    backLogic: (card, board) => {
      const targets = [...gameState.enemy.board.filter(c => c), {hp: gameState.enemy.hp}];
      const target = targets[Math.floor(Math.random() * targets.length)];
      target.hp -= 1;
    }
  },

  { 
    id: 10,
    name: "Burbaloni Luliloli", 
    hp: 4, 
    atk: 1, 
    cost: 3, 
    effect: "Burr baloni luli loli, capibarello cocossini, √® molto raro trovare sulle coste di bali",
    bgImage: "url('img/Burbaloni.webp')",
    frontEffect: "Soigne 1 PV √† votre joueur apr√®s avoir attaqu√©",
    backEffect: "Soigne 2 PV √† une carte al√©atoire √† la fin du tour",
    frontLogic: (attacker, target) => {
      basicAttack(attacker, target);
      healPlayer(1);
    },
    backLogic: (card, board) => {
      const aliveCards = board.filter(c => c && c.hp > 0);
      if (aliveCards.length > 0) {
        const randomCard = aliveCards[Math.floor(Math.random() * aliveCards.length)];
        randomCard.hp += 2;
      }
    }
  },

  { 
    id: 11,
    name: "Bombombini Gusini", 
    hp: 2, 
    atk: 2, 
    cost: 4, 
    effect: "bombombini gusini fratello bombardiro crocodilo che svolge tutte le stesse funzioni del fratello e d√† bombe alla gente.",
    bgImage: "url('img/Bombombini_Gusini.webp')",
    frontEffect: "Attaque normalement",
    backEffect: "Si mort, invoque une copie d'une carte alli√©e al√©atoire",
    frontLogic: (attacker, target) => basicAttack(attacker, target),
    backLogic: (card, board) => {}, // Effet g√©r√© dans la destruction
    onDestroy: (card, board) => {
      const aliveCards = board.filter(c => c && c.hp > 0);
      if (aliveCards.length > 0) {
        const randomCard = aliveCards[Math.floor(Math.random() * aliveCards.length)];
        const emptySlot = board.findIndex(c => !c);
        if (emptySlot !== -1) {
          board[emptySlot] = {...randomCard, hp: 1};
        }
      }
    }
  },

  { 
    id: 12,
    name: "Ballerina Capuchina", 
    hp: 1, 
    atk: 0, 
    cost: 2, 
    effect: "Ballerina Capuchina, mi mi mi miiii. √à la moglie di Capuchino Assassino.",
    bgImage: "url('img/BallerinaCapuchina.webp')",
    frontEffect: "50% de chance d'√©viter les attaques",
    backEffect: "L'ennemi a 25% de chance de rater ses attaques",
    frontLogic: (attacker, target) => {}, // Effet passif
    backLogic: (card, board) => {} // Effet passif
  },

  { 
    id: 13,
    name: "Capuchino Assassino", 
    hp: 7, 
    atk: 7, 
    cost: 6, 
    effect: " Cappuccino Assassino is extremely fast",
    bgImage: "url('img/Hq720.jpg')",
    frontEffect: "Attaque une carte al√©atoire (alli√©e ou ennemie)",
    backEffect: "Inflige 2 d√©g√¢ts √† toutes les cartes √† la fin du tour",
    frontLogic: (attacker, target) => {
      const allCards = [...gameState.player.board, ...gameState.enemy.board].filter(c => c);
      const randomTarget = allCards[Math.floor(Math.random() * allCards.length)];
      basicAttack(attacker, randomTarget);
    },
    backLogic: (card, board) => {
      gameState.player.board.forEach(c => c && (c.hp -= 2));
      gameState.enemy.board.forEach(c => c && (c.hp -= 2));
    }
  },

  { 
    id: 14,
    name: "Trulimero Trulicina", 
    hp: 5, 
    atk: 3, 
    cost: 5, 
    effect: "trulimero trulichima, il pretiletine in piscina, formaggio sulla trulalima, ma chi chiama la tazzina?",
    bgImage: "url('img/Trulimero_Trulichina.webp')",
    frontEffect: "Donne +1 ATK √† toutes les autres cartes",
    backEffect: "Pioche 1 carte √† la fin du tour",
    frontLogic: (attacker, target) => {
      buffAllies(gameState.player.board, 1, 0);
      basicAttack(attacker, target);
    },
    backLogic: (card, board) => {
      if (gameState.player.hand.length < 5) {
        drawCardToHand();
      }
    }
  }
];
    

    // Effets de base
    function basicAttack(attacker, target, callback) {
      if (target && target.name === "Mirage Melon" && Math.random() < 0.5) {
    if (callback) callback();
    return;
  }
      if (!target) {
        // Attaque directe du joueur
        createAttackAnimation(attacker, null, () => {
          gameState.enemy.hp -= attacker.atk;
          if (gameState.enemy.hp <= 0) endGame("Victoire !");
          updateUI();
          if (callback) callback();
        });
      } else {
        // Attaque une carte
        createAttackAnimation(attacker, target, () => {
          target.hp -= attacker.atk;
          if (target.hp <= 0) {
            if (target.onDestroy) {
    target.onDestroy(target, gameState.enemy.board);
  }
            const index = gameState.enemy.board.indexOf(target);
            gameState.enemy.board[index] = null;
          }
          updateUI();
          if (callback) callback();
        });
      }
    }

    

    function updateUltimateProgress() {
  // Pour le joueur
  gameState.player.board.forEach(card => {
    if (card && card.ultimate) {
      if (!card.ultimateProgress) card.ultimateProgress = 0;
      card.ultimateProgress++;
    }
  });

  // Pour l'ennemi
  gameState.enemy.board.forEach(card => {
    if (card && card.ultimate) {
      if (!card.ultimateProgress) card.ultimateProgress = 0;
      card.ultimateProgress++;
    }
  });
}

function useUltimate() {
  if (gameState.ultimateReady === null) return;
  
  const card = gameState.player.board[gameState.ultimateReady];
  if (card && card.ultimate) {
    // V√©rifiez le mana
    if (gameState.player.mana < card.ultimate.cost) {
      alert(`Pas assez de mana (n√©cessite ${card.ultimate.cost})`);
      return;
    }
    
    gameState.player.mana -= card.ultimate.cost;
    card.ultimate.execute(card, gameState.player.board);
    card.ultimateProgress = 0;
    gameState.ultimateReady = null;
    document.getElementById('ultimate-btn').disabled = true;
    updateUI();
    renderBoard();
  }
}

    function createAttackAnimation(attacker, target, callback) {
  const attackerEl = findCardElement(attacker);
  if (!attackerEl) {
    if (callback) callback();
    return;
  }
  
  const attackerRect = attackerEl.getBoundingClientRect();
  const animation = document.createElement('div');
  animation.className = 'attack-animation';
  animation.style.left = (attackerRect.left + attackerRect.width/2 - 25) + 'px';
  animation.style.top = (attackerRect.top + attackerRect.height/2 - 25) + 'px';
  document.body.appendChild(animation);
  
  let targetRect;
  
  if (target) {
    // Attaque une carte
    const targetEl = findCardElement(target);
    if (targetEl) {
      targetRect = targetEl.getBoundingClientRect();
    }
  } else {
    // Attaque directe du joueur
    // CIBLE CORRIG√âE : On prend la zone de vie du joueur attaqu√©
    const targetHpEl = (gameState.turn === 'player') 
      ? document.getElementById('enemy-hp').parentElement 
      : document.getElementById('player-hp').parentElement;
    
    targetRect = targetHpEl.getBoundingClientRect();
  }
  
  // Animation vers la cible
  if (targetRect) {
    animation.style.left = (targetRect.left + targetRect.width/2 - 25) + 'px';
    animation.style.top = (targetRect.top + targetRect.height/2 - 25) + 'px';
  }
  
  setTimeout(() => {
    animation.remove();
    if (callback) callback();
  }, 500);
}

    function findCardElement(card) {
      // Cherche dans la zone joueur
      for (let i = 0; i < gameState.player.board.length; i++) {
        if (gameState.player.board[i] === card) {
          const zone = document.getElementById('player-zone');
          if (zone && zone.children[i]) {
            return zone.children[i].querySelector('.card');
          }
        }
      }
      
      // Cherche dans la zone ennemie
      for (let i = 0; i < gameState.enemy.board.length; i++) {
        if (gameState.enemy.board[i] === card) {
          const zone = document.getElementById('enemy-zone');
          if (zone && zone.children[i]) {
            return zone.children[i].querySelector('.card');
          }
        }
      }
      
      return null;
    }

    function buffAllies(board, atkBuff, hpBuff) {
      board.forEach(card => {
        if (card) {
          card.atk += atkBuff;
          card.hp += hpBuff;
        }
      });
    }

    function buffCard(card, atkBuff, hpBuff) {
      card.atk += atkBuff;
      card.hp += hpBuff;
    }

    function healPlayer(amount) {
      gameState.player.hp = Math.min(20, gameState.player.hp + amount);
      updateUI();
    }

    function damageEnemy(amount) {
      gameState.enemy.hp -= amount;
      if (gameState.enemy.hp <= 0) endGame("Victoire !");
      updateUI();
    }

    // Initialisation du jeu
    function initGame() {
      // Cr√©er un deck de 20 cartes (4 exemplaires de chaque)
      gameState.player.deck = [];
      for (let i = 0; i < 4; i++) {
        cardsLibrary.forEach(card => {
          gameState.player.deck.push({...card});
        });
      }
      
      // M√©langer le deck
      shuffleDeck(gameState.player.deck);
      
      // Pioche initiale
      for (let i = 0; i < 3; i++) {
        drawCardToHand();
      }

      gameState.player.exhaustedCards = [];
      gameState.enemy.exhaustedCards = [];
      
      updateUI();
      renderBoard();
      renderHand();
    }

    function shuffleDeck(deck) {
      for (let i = deck.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [deck[i], deck[j]] = [deck[j], deck[i]];
      }
    }

    function drawCardToHand() {
      if (gameState.player.hand.length >= 5) {
        alert("Votre main est pleine (5 cartes maximum)");
        return false;
      }
      if (gameState.player.deck.length === 0) {
        alert("Plus de cartes dans le deck !");
        return false;
      }
      gameState.player.hand.push(gameState.player.deck.pop());
      renderHand();
      return true;
    }

    function drawCard() {
      if (gameState.turn !== 'player') return;
      if (gameState.player.mana < 3) {
        alert("Pas assez de mana pour piocher (co√ªt: 3)");
        return;
      }
      gameState.player.mana -= 3;
      drawCardToHand();
      updateUI();
    }

    function selectCard(index) {
  // V√©rifier si les interactions sont autoris√©es
  if (gameState.turn !== 'player' || !gameState.canPlayCards) return;
  
  // D√©s√©lectionner si on clique sur la m√™me carte
  if (gameState.player.selectedCard === index) {
    gameState.player.selectedCard = null;
    hideCardDetails();
    clearHighlights();
    renderHand();
    return;
  }
  
  gameState.player.selectedCard = index;
  showCardDetails(gameState.player.hand[index]);
  highlightAvailableSlots();
  renderHand();
}

    function showCardDetails(card) {
      const detailsEl = document.getElementById('card-details');
      detailsEl.innerHTML = `
        <div class="card-details-name">${card.name}</div>
        <div class="card-details-stats">
          <div class="card-details-stat">
            <div>ATK</div>
            <div class="card-details-stat-value">${card.atk}</div>
          </div>
          <div class="card-details-stat">
            <div>HP</div>
            <div class="card-details-stat-value">${card.hp}</div>
          </div>
          <div class="card-details-stat">
            <div>CO√õT</div>
            <div class="card-details-stat-value">${card.cost}</div>
          </div>
        </div>
        <div class="card-details-effect">${card.effect}</div>
        <div class="position-effects">
          <div class="position-effect front">
            <h4>En Position Avant</h4>
            <div>${card.frontEffect}</div>
          </div>
          <div class="position-effect back">
            <h4>En Position Arri√®re</h4>
            <div>${card.backEffect}</div>
          </div>
        </div>
      `;
      if (card.ultimate) {
  detailsEl.innerHTML += `
    <div class="ultimate-details">
      <h4>ULTIMATE (${card.ultimate.cost}‚ú®)</h4>
      <p>${card.ultimate.effect}</p>
      <p>Charge en ${card.ultimate.turnsNeeded-1} tours</p>
    </div>
  `;
}
      detailsEl.classList.add('active');
    }

    function hideCardDetails() {
      document.getElementById('card-details').classList.remove('active');
    }

    function placeCard(slotIndex) {
      if (gameState.turn !== 'player') return;
      if (gameState.player.selectedCard === null) return;
      if (gameState.player.board[slotIndex] !== null) return;
      if (!gameState.canPlayCards) return;
      
      const card = gameState.player.hand[gameState.player.selectedCard];
      
      if (gameState.player.mana < card.cost) {
        alert("Pas assez de mana pour cette carte");
        return;
      }
      
      gameState.player.mana -= card.cost;
      
      // Cr√©er une nouvelle carte avec la propri√©t√© "canAttack" √† false
      const newCard = {
        ...card,
        canAttack: false, // Ne peut pas attaquer le tour o√π elle est pos√©e
        ultimateProgress: 0 // <-- Initialiser la progression d'ulti
      };
      
      gameState.player.board[slotIndex] = newCard;
      gameState.player.hand.splice(gameState.player.selectedCard, 1);
      
      gameState.player.selectedCard = null;
      hideCardDetails();
      clearHighlights();
      renderHand();
      renderBoard();
      updateUI();
    }

    function selectAttacker(slotIndex) {
  if (gameState.turn !== 'player') return;
  if (gameState.player.board[slotIndex] === null) return;
  
  const card = gameState.player.board[slotIndex];
  
  // V√©rifier si la carte peut attaquer
  if (!card.canAttack || gameState.player.exhaustedCards.includes(slotIndex)) {
    return;
  }

  // Si la carte a son ulti pr√™t
  if (card?.ultimateProgress >= card?.ultimate?.turnsNeeded) {
    gameState.ultimateReady = slotIndex;
    document.getElementById('ultimate-btn').disabled = false;
    renderBoard();
    return;
  }
  
  // D√©s√©lectionner si on clique sur la m√™me carte
  if (gameState.player.selectedAttacker === slotIndex) {
    gameState.player.selectedAttacker = null;
    clearHighlights();
    renderBoard();
    renderHand(); // Ajouter cette ligne pour rafra√Æchir l'affichage
    return;
  }
  
  gameState.player.selectedAttacker = slotIndex;
  highlightAttackTargets();
  renderBoard();
  renderHand(); // Ajouter cette ligne pour coh√©rence
}
function highlightAttackTargets() {
  clearHighlights();
  
  gameState.enemy.board.forEach((slot, index) => {
    if (slot !== null) { // Supprimer la v√©rification exhaustedCards
      const enemyZone = document.getElementById('enemy-zone');
      if (enemyZone && enemyZone.children[index]) {
        enemyZone.children[index].classList.add('attackable');
      }
    }
  });

  gameState.enemy.board.forEach((enemyCard, index) => {
    if (enemyCard) {
      const enemyZone = document.getElementById('enemy-zone');
      if (enemyZone && enemyZone.children[index]) {
        enemyZone.children[index].classList.add('attackable');
      }
    }
  });

  // Activer l'attaque directe si front
  if (gameState.player.selectedAttacker < 2) {
    document.getElementById('enemy-hp').parentElement.classList.add('attackable-player');
  }
}


function attack(targetIndex) {
  if (gameState.turn !== 'player') return;
  if (gameState.player.selectedAttacker === null) return;

  const attackerIndex = gameState.player.selectedAttacker;
  const attacker = gameState.player.board[attackerIndex];
  if (!attacker) return;

  gameState.canPlayCards = false;
  gameState.player.exhaustedCards.push(attackerIndex);

  let target = null;
  let isDirectAttack = false;
  
  if (typeof targetIndex === 'number') {
    target = gameState.enemy.board[targetIndex];
  } else {
    isDirectAttack = true;
  }

  const position = attackerIndex < 2 ? 'front' : 'back';

  const resolveAttack = () => {
    if (position === 'front') {
      if (isDirectAttack) {
        gameState.enemy.hp = Math.max(0, gameState.enemy.hp - attacker.atk);
      } else if (target) {
        target.hp -= attacker.atk;
      }
    }

    // Appliquer les effets de position arri√®re m√™me pour les attaques
    if (position === 'back' && attacker.backLogic) {
      attacker.backLogic(attacker, gameState.player.board);
    }

    // Nettoyer les cartes d√©truites
    gameState.enemy.board = gameState.enemy.board.map(card => 
      card && card.hp > 0 ? card : null
    );

    updateGameState(true);
    gameState.player.selectedAttacker = null;
    gameState.canPlayCards = true;
  };

  createAttackAnimation(attacker, target, resolveAttack);
}

    function highlightAvailableSlots() {
      // R√©initialiser les highlights
      clearHighlights();
      
      // Mettre en √©vidence les emplacements disponibles
      gameState.player.board.forEach((slot, index) => {
        if (slot === null) {
          document.getElementById('player-zone').children[index].classList.add('placeable');
        }
      });
    }

    function clearHighlights() {
  // R√©initialiser tous les highlights
  document.querySelectorAll('.highlight, .placeable, .selected-board-card, .attackable, .attackable-player').forEach(el => {
    el.classList.remove('highlight', 'placeable', 'selected-board-card', 'attackable', 'attackable-player');
  });
}


    function endTurn() {
      if (gameState.turn !== 'player') return;
      
      // Appliquer les effets de fin de tour pour les cartes en arri√®re
      gameState.player.board.forEach((card, index) => {
        if (card && index >= 2) { // Cartes en arri√®re
          card.backLogic(card, gameState.player.board);
        }
      });



      
      // R√©initialiser les cartes √©puis√©es
      gameState.player.exhaustedCards = [];
      
      // Passer au tour de l'ennemi
      gameState.turn = 'enemy';
      document.getElementById('turn-indicator').textContent = "TOUR DE L'ENNEMI";
      document.getElementById('turn-indicator').className = 'turn-indicator enemy-turn';
      // Apr√®s le tour de l'ennemi, appliquer ses effets de support
    gameState.enemy.board.forEach((card, index) => {
        if (card && index >= 2) { // Cartes en arri√®re
            card.backLogic(card, gameState.enemy.board);
        }
    });
      
      // Augmenter le mana max si besoin
      if (gameState.enemy.maxMana < 10) {
        gameState.enemy.maxMana++;
      }
      gameState.enemy.mana = gameState.enemy.maxMana;


    
      
      updateUI();
      
      // L'IA joue apr√®s un court d√©lai
      setTimeout(enemyTurn, 1000);
    }


    function enemyTurn() {
    // Phase 1: Gestion des cartes sp√©ciales et ulti
    gameState.enemy.board.forEach((card, index) => {
        if (card && card.ultimate) {
            // V√©rifier si l'ulti est pr√™te
            if (card.ultimateProgress >= card.ultimate.turnsNeeded &&
                gameState.enemy.mana >= card.ultimate.cost) {
                card.ultimate.execute(card, gameState.enemy.board);
                gameState.enemy.mana -= card.ultimate.cost;
                card.ultimateProgress = 0;
            }
        }
    });

    // Phase 2: Placement strat√©gique des cartes
    const playableCards = cardsLibrary.filter(c => c.cost <= gameState.enemy.mana);
    let attempts = 0;

    // Trier les cartes par priorit√© (co√ªt √©lev√© d'abord)
    playableCards.sort((a, b) => b.cost - a.cost);

    while (playableCards.length > 0 && attempts < 5 && gameState.enemy.mana > 0) {
        const card = playableCards.shift();
        const availableSlots = gameState.enemy.board
            .map((slot, i) => slot === null ? i : null)
            .filter(val => val !== null);

        if (availableSlots.length === 0) break;

        // Strat√©gie de placement :
        // - Cartes avec ATK √©lev√© devant (slots 0-1)
        // - Cartes de support derri√®re (slots 2-3)
        const preferredSlots = card.atk > card.hp ? [0, 1] : [2, 3];
        const validSlots = availableSlots.filter(s => preferredSlots.includes(s));

        const slotIndex = validSlots.length > 0 ? 
            validSlots[Math.floor(Math.random() * validSlots.length)] :
            availableSlots[Math.floor(Math.random() * availableSlots.length)];

        if (Math.random() < 0.7) { // 70% de chance de jouer la carte
            gameState.enemy.board[slotIndex] = {
                ...card,
                canAttack: false,
                ultimateProgress: 0
            };
            gameState.enemy.mana -= card.cost;
        }
        
        attempts++;
    }

    // Phase 3: Attaques strat√©giques
    const attackingCards = gameState.enemy.board
        .map((card, index) => ({card, index}))
        .filter(({card}) => card && card.canAttack)
        .sort((a, b) => {
            // Priorit√© aux cartes frontales et ATK √©lev√©
            const aScore = (a.index < 2 ? 2 : 0) + a.card.atk;
            const bScore = (b.index < 2 ? 2 : 0) + b.card.atk;
            return bScore - aScore;
        });

    // Ex√©cuter les attaques de mani√®re strat√©gique
    const executeStrategicAttack = (index = 0) => {
        if (index >= attackingCards.length) {
            // Phase 4: Activation des effets de support
            gameState.enemy.board.forEach((card, i) => {
                if (card && i >= 2) { // Cartes en arri√®re
                    card.backLogic?.(card, gameState.enemy.board);
                }
            });
            setTimeout(startPlayerTurn, 1000);
            return;
        }

        const {card, index: slotIndex} = attackingCards[index];
        gameState.enemy.exhaustedCards.push(slotIndex);

        let target = null;
        if (slotIndex < 2) { // Position avant
            // Cibler les cartes faibles ou attaquer directement
            const validTargets = gameState.player.board
                .filter(c => c !== null && c.hp <= card.atk);
            
            if (validTargets.length > 0 && Math.random() < 0.8) {
                target = validTargets[Math.floor(Math.random() * validTargets.length)];
            } else {
                // Attaque directe si possible
                if (Math.random() < 0.6) {
                    target = null;
                } else {
                    const frontTargets = gameState.player.board.slice(0, 2).filter(c => c);
                    target = frontTargets[Math.floor(Math.random() * frontTargets.length)];
                }
            }
        }

        createAttackAnimation(card, target, () => {
            if (target) {
                target.hp -= card.atk;
                if (target.hp <= 0) {
                    const targetIndex = gameState.player.board.indexOf(target);
                    gameState.player.board[targetIndex] = null;
                }
            } else {
                gameState.player.hp -= card.atk;
                if (gameState.player.hp <= 0) endGame("D√©faite !");
            }
            
            updateUI();
            renderBoard();
            executeStrategicAttack(index + 1);
        });
    };

    executeStrategicAttack();
}

function startPlayerTurn() {
  updateUltimateProgress(); // <-- Ajoutez cette ligne

  gameState.turn = 'player';
  
  // R√©initialiser le mana
  if (gameState.player.maxMana < 10) {
    gameState.player.maxMana++;
  }
  gameState.player.mana = gameState.player.maxMana; // Cette ligne √©tait manquante
  
  // R√©initialiser les cartes alli√©es
  gameState.player.board.forEach((card, index) => {
    if (card) {
      card.canAttack = true;
      gameState.player.exhaustedCards = gameState.player.exhaustedCards.filter(i => i !== index);
    }
  });

    // Pioche automatique en d√©but de tour
    if (gameState.player.hand.length < 5 && gameState.player.deck.length > 0) {
    drawCardToHand();
  }

  updateGameState(true);
  document.getElementById('turn-indicator').className = 'turn-indicator player-turn';
  document.getElementById('turn-indicator').textContent = "VOTRE TOUR";
}

    function endGame(message) {
      alert(message);
      // R√©initialiser le jeu
      gameState.player = { 
        hp: 20, 
        mana: 1, 
        maxMana: 1, 
        deck: [], 
        hand: [], 
        board: Array(4).fill(null),
        selectedCard: null,
        selectedAttacker: null,
        canPlayCards: true
      };
      gameState.enemy = { 
        hp: 20, 
        mana: 1, 
        maxMana: 1, 
        board: Array(4).fill(null) 
      };
      gameState.turn = 'player';
      initGame();
    }

    function renderBoard() {
      renderZone('player-zone', gameState.player.board, 'ally');
      renderZone('enemy-zone', gameState.enemy.board, 'enemy');
    }

    function renderZone(zoneId, board, type) {
  const zone = document.getElementById(zoneId);
  zone.innerHTML = '';

  board.forEach((card, index) => {
    const slot = document.createElement('div');
    slot.className = `slot ${type}`;

    // D√©termine la position (invers√©e pour l'ennemi)
    let positionIndex = index;
    if (type === 'enemy') {
      positionIndex = (index < 2) ? index + 2 : index - 2;
    }
    
    if (!card) {
      const positionIcon = document.createElement('div');
      positionIcon.className = 'position-icon';
      positionIcon.textContent = positionIndex < 2 ? 'üõ°Ô∏è' : 'üèπ';
      slot.appendChild(positionIcon);
    }
    if (card) {
      const cardEl = document.createElement('div');
      cardEl.className = 'card';

      // Ajouter la jauge d'ulti si la carte en a une
      if (card.ultimate) {
          


          // Mettre en √©vidence si l'ulti est pr√™t
          if (card.ultimateProgress >= card.ultimate.turnsNeeded) {
            cardEl.classList.add('card-ready-for-ultimate');
          }
        }

      // Highlight selected card (ally only)
      if (type === 'ally' && gameState.player.selectedAttacker === index) {
        cardEl.classList.add('selected-board-card');
      }

      // Ally cards that can't attack
      if (type === 'ally' && (!card.canAttack || gameState.player.exhaustedCards.includes(index))) {
        cardEl.classList.add('unusable-card');
      }
  // Style d'arri√®re-plan dynamique
  cardEl.style.backgroundImage = card.bgImage || 'linear-gradient(135deg, #444 0%, #333 100%)';
  cardEl.style.backgroundSize = 'cover';
  cardEl.style.backgroundPosition = 'center';
  // Construire tout le HTML en une fois
  let cardHTML = `
    <div class="mana-cost">${card.cost}</div>
    <div class="card-name">${card.name}</div>
    <div class="card-stats">
      <div class="card-stat">
        <div>ATK</div>
        <div class="card-stat-value">${card.atk}</div>
      </div>
      <div class="card-stat">
        <div>HP</div>
        <div class="card-stat-value">${card.hp}</div>
      </div>
    </div>
  `;

  // Ajouter la barre d'ulti si n√©cessaire
  if (card.ultimate) {
    const progress = Math.min(100, (card.ultimateProgress / card.ultimate.turnsNeeded) * 100);
    cardHTML += `
      <div class="ultimate-progress">
        <div class="ultimate-progress-fill" style="width: ${progress}%"></div>
      </div>
    `;
  }

  cardEl.innerHTML = cardHTML;

      // Ally card click handling
      if (type === 'ally') {
        if (gameState.turn === 'player' && card.canAttack && !gameState.player.exhaustedCards.includes(index)) {
          slot.onclick = () => {
            selectAttacker(index);
            updateGameState();
          };
        }
      }

      slot.appendChild(cardEl);
    } else if (type === 'ally' && gameState.turn === 'player') {
      // Empty ally slot
      slot.onclick = () => {
        if (gameState.player.selectedCard !== null) {
          placeCard(index);
          updateGameState();
        }
      };
    }

    // Enemy card click handling
    if (type === 'enemy' && card && gameState.player.selectedAttacker !== null && gameState.turn === 'player') {
      slot.onclick = () => {
        attack(index);
        updateGameState();
      };
    }
    if (type === 'enemy' && card && gameState.player.selectedAttacker !== null) {
  slot.onclick = () => {
    attack(index);
    updateGameState();
  };
  if (gameState.turn === 'player') {
    slot.classList.add('attackable');
  }
}

    zone.appendChild(slot);
  });

  // Direct attack handling
  if (type === 'enemy') {
    const enemyHpEl = document.getElementById('enemy-hp').parentElement;
    if (gameState.player.selectedAttacker !== null && gameState.turn === 'player' && 
        gameState.player.selectedAttacker < 2) {
      enemyHpEl.onclick = () => {
        attack(null);
        updateGameState();
      };
      enemyHpEl.classList.add('attackable-player');
    } else {
      enemyHpEl.onclick = null;
      enemyHpEl.classList.remove('attackable-player');
    }
  }
}

// Nouvelle fonction pour mettre √† jour l'√©tat du jeu
function updateGameState(forceRender = false) {
  // Nettoyer les cartes d√©truites
  gameState.player.board = gameState.player.board.map(card => {
    if (!card) return null;
    return card.hp > 0 ? card : null;
  });

  gameState.enemy.board = gameState.enemy.board.map(card => {
    if (!card) return null;
    return card.hp > 0 ? card : null;
  });

  // Mise √† jour conditionnelle du rendu
  if (forceRender || Date.now() - lastRender > 100) {
    renderBoard();
    renderHand();
    updateUI();
    lastRender = Date.now();
  }

  // V√©rifier les conditions de victoire
  if (gameState.player.hp <= 0) endGame("D√©faite !");
  if (gameState.enemy.hp <= 0) endGame("Victoire !");
}

let lastRender = 0;


    function renderHand() {
      const handEl = document.getElementById('hand');
      handEl.innerHTML = '';
      
      gameState.player.hand.forEach((card, index) => {
        const cardEl = document.createElement('div');
        cardEl.className = 'card hand-card';
        
        // Mise en surbrillance de la carte s√©lectionn√©e
        if (gameState.player.selectedCard === index) {
          cardEl.classList.add('selected-card');
        }
        
        // Indicateur visuel pour les cartes jouables
        if (gameState.player.mana >= card.cost) {
          cardEl.classList.add('playable-card');
        }
          // Style d'arri√®re-plan dynamique
  cardEl.style.backgroundImage = card.bgImage || 'linear-gradient(135deg, #444 0%, #333 100%)';
  cardEl.style.backgroundSize = 'cover';
  cardEl.style.backgroundPosition = 'center';
        cardEl.innerHTML = `
          <div class="mana-cost">${card.cost}</div>
          <div class="card-name">${card.name}</div>
          <div class="card-stats">
            <div class="card-stat">
              <div>ATK</div>
              <div class="card-stat-value">${card.atk}</div>
            </div>
            <div class="card-stat">
              <div>HP</div>
              <div class="card-stat-value">${card.hp}</div>
            </div>
          </div>
        `;
        
        cardEl.onclick = () => selectCard(index);
        handEl.appendChild(cardEl);
      });
    }

    function updateUI() {
      document.getElementById('player-hp').textContent = gameState.player.hp;
      document.getElementById('enemy-hp').textContent = gameState.enemy.hp;
      document.getElementById('player-mana').textContent = gameState.player.mana;
      document.getElementById('enemy-mana').textContent = gameState.enemy.mana;
      
      // D√©sactiver le bouton pioche si pas assez de mana
      document.getElementById('draw-btn').disabled = gameState.player.mana < 3 || gameState.turn !== 'player';
    }

    // D√©marrer le jeu
    initGame();
    
    // Service Worker registration
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('sw.js')
          .then(registration => {
            console.log('ServiceWorker registration successful');
          })
          .catch(err => {
            console.log('ServiceWorker registration failed: ', err);
          });
      });
    }
  </script>
</body>
</html>


