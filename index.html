<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="mobile-web-app-capable" content="yes" />
  <title>Bombardiro Battle</title>
  <link rel="manifest" href="manifest.json" />
  <link rel="icon" href="icon-192.png" type="image/png" />
  <style>
    :root {
      --card-width: 22vw;
      --card-height: calc(var(--card-width) * 1.4);
      --hand-height: calc(var(--card-height) * 0.8);
    }
    
    * {
      box-sizing: border-box;
      touch-action: manipulation;
    }
    
    body {
      font-family: 'Comic Sans MS', cursive, sans-serif;
      background: #1e1e1e;
      color: #fff;
      margin: 0;
      padding: 0;
      overflow: hidden;
      width: 100vw;
      height: 100vh;
      display: flex;
      flex-direction: column;
      position: fixed;
    }
    
    .game-container {
      flex: 1;
      display: flex;
      flex-direction: column;
      width: 100%;
      height: 100%;
      margin: 0 auto;
      max-width: 800px;
      position: relative;
    }
    
    .ui-bar {
      display: flex;
      justify-content: space-between;
      width: 100%;
      padding: 8px 10px;
      background: #333;
      font-size: 14px;
      flex-shrink: 0;
    }
    
    .turn-indicator {
      text-align: center;
      padding: 5px;
      font-weight: bold;
      background: #333;
      font-size: 14px;
      flex-shrink: 0;
    }
    
    .player-turn {
      background: #4CAF50;
    }
    
    .enemy-turn {
      background: #F44336;
    }
    
    .board {
      flex: 1;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      padding: 5px 0;
      overflow: hidden;
    }
    
    .zone {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 8px;
      padding: 0 8px;
      min-height: calc(var(--card-height) + 10px);
    }
    
    .slot {
      background: #555;
      border: 2px solid transparent;
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      aspect-ratio: 2/3;
      position: relative;
      transition: all 0.2s;
      height: var(--card-height);
    }
    
    .slot.ally { border-color: #4CAF50; }
    .slot.enemy { border-color: #F44336; }
    .slot.highlight { 
      border: 3px solid #FFEB3B;
      box-shadow: 0 0 10px #FFEB3B;
    }
    .slot.attackable {
      border: 3px solid #F44336;
      box-shadow: 0 0 10px #F44336;
    }
    .slot.placeable {
      border: 3px solid #2196F3;
      box-shadow: 0 0 10px #2196F3;
    }
    
    .card {
      background: linear-gradient(135deg, #444 0%, #333 100%);
      border: 2px solid #fff;
      border-radius: 8px;
      padding: 8px;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      font-size: 12px;
      text-align: center;
      box-shadow: 0 3px 6px rgba(0,0,0,0.3);
      position: relative;
      overflow: hidden;
    }
    
    .card::before {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 5px;
      background: linear-gradient(90deg, #FF5722, #FFC107);
    }
    
    .card-name {
      font-weight: bold;
      font-size: 14px;
      margin-bottom: 5px;
      color: #FFC107;
    }
    
    .card-stats {
      display: flex;
      justify-content: space-around;
      margin: 5px 0;
    }
    
    .card-stat {
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    
    .card-stat-value {
      font-weight: bold;
      font-size: 16px;
    }
    
    .card-effect {
      font-size: 10px;
      color: #BDBDBD;
      margin-top: 5px;
      overflow: hidden;
      text-overflow: ellipsis;
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
    }
    
    .mana-cost {
      position: absolute;
      top: 5px;
      right: 5px;
      background: #2196F3;
      color: white;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      font-size: 12px;
    }
    
    .hp-bar {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 5px;
      background: #F44336;
    }
    
    .hp-bar-fill {
      height: 100%;
      background: #4CAF50;
    }
    
    .hand-container {
      height: var(--hand-height);
      width: 100%;
      position: relative;
      flex-shrink: 0;
    }
    
    .hand {
      display: flex;
      gap: 8px;
      padding: 0 8px;
      width: 100%;
      height: 100%;
      overflow-x: auto;
      scroll-snap-type: x mandatory;
      scrollbar-width: none;
    }
    
    .hand::-webkit-scrollbar {
      display: none;
    }
    
    .hand-card {
      scroll-snap-align: center;
      flex: 0 0 calc(var(--card-width) * 0.8);
      height: calc(var(--hand-height) - 10px);
    }
    
    .controls {
      display: flex;
      justify-content: space-between;
      width: 100%;
      padding: 8px;
      background: #333;
      flex-shrink: 0;
    }
    
    .btn {
      padding: 8px 12px;
      border: none;
      border-radius: 5px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.2s;
      font-size: 14px;
    }
    
    .btn-primary {
      background: #4CAF50;
      color: white;
    }
    
    .btn-primary:hover {
      background: #45a049;
    }
    
    .btn-secondary {
      background: #2196F3;
      color: white;
    }
    
    .btn-secondary:hover {
      background: #0b7dda;
    }
    
    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    /* Affichage des d√©tails de la carte s√©lectionn√©e */
    .card-details {
      position: absolute;
      top: 50px;
      left: 0;
      right: 0;
      background: rgba(51, 51, 51, 0.9);
      padding: 10px;
      z-index: 50;
      border-bottom: 2px solid #FFC107;
      display: none;
    }
    
    .card-details.active {
      display: block;
    }
    
    .card-details-name {
      font-weight: bold;
      font-size: 16px;
      color: #FFC107;
      margin-bottom: 5px;
      text-align: center;
    }
    
    .card-details-stats {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin-bottom: 5px;
    }
    
    .card-details-stat {
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    
    .card-details-stat-value {
      font-weight: bold;
      font-size: 18px;
    }
    
    .card-details-effect {
      font-size: 12px;
      text-align: center;
      margin-bottom: 5px;
    }
    
    .position-effects {
      display: flex;
      justify-content: space-between;
      margin-top: 10px;
    }
    
    .position-effect {
      flex: 0 0 48%;
      padding: 8px;
      background: rgba(0,0,0,0.3);
      border-radius: 8px;
      font-size: 12px;
    }
    
    .position-effect h4 {
      margin: 0 0 5px 0;
      color: #FFC107;
      font-size: 14px;
    }
    
    .position-effect.front h4::before {
      content: "üõ°Ô∏è ";
    }
    
    .position-effect.back h4::before {
      content: "üèπ ";
    }
    
    .selected-card {
      box-shadow: 0 0 15px #FFEB3B;
      transform: scale(1.05);
    }
    
    @media (min-width: 600px) {
      :root {
        --card-width: 18vw;
      }
      
      .zone {
        grid-template-columns: repeat(4, 1fr);
      }
      
      .slot:nth-child(1), .slot:nth-child(2) {
        grid-row: 1;
      }
      
      .slot:nth-child(3), .slot:nth-child(4) {
        grid-row: 2;
      }
      
      .card-name {
        font-size: 16px;
      }
      
      .card-stat-value {
        font-size: 18px;
      }
      
      .card-effect {
        font-size: 12px;
      }
    }
    
    @media (max-width: 400px) {
      :root {
        --card-width: 24vw;
      }
      
      .card-name, .card-details-name {
        font-size: 12px;
      }
      
      .card-stat-value, .card-details-stat-value {
        font-size: 14px;
      }
      
      .card-effect, .card-details-effect {
        font-size: 10px;
      }
      
      .btn {
        padding: 6px 10px;
        font-size: 12px;
      }
    }
  </style>
</head>
<body>
  <div class="turn-indicator player-turn" id="turn-indicator">VOTRE TOUR</div>
  
  <div class="card-details" id="card-details"></div>
  
  <div class="ui-bar">
    <div>Ennemi: <span id="enemy-hp">20</span> ‚ù§Ô∏è</div>
    <div>Mana: <span id="enemy-mana">1</span>/10 ‚ú®</div>
  </div>

  <div class="game-container">
    <div class="board">
      <div class="zone enemy-zone" id="enemy-zone"></div>
      <div class="zone player-zone" id="player-zone"></div>
    </div>
    
    <div class="hand-container">
      <div class="hand" id="hand"></div>
    </div>
  </div>
  
  <div class="ui-bar">
    <div>Vous: <span id="player-hp">20</span> ‚ù§Ô∏è</div>
    <div>Mana: <span id="player-mana">1</span>/10 ‚ú®</div>
  </div>

  <div class="controls">
    <button class="btn btn-secondary" id="draw-btn" onclick="drawCard()">Piocher (3‚ú®)</button>
    <button class="btn btn-primary" id="end-turn-btn" onclick="endTurn()">Fin du tour</button>
  </div>

  <script>
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('sw.js');
    }
    // √âtat du jeu
    const gameState = {
      player: { 
        hp: 20, 
        mana: 1, 
        maxMana: 1, 
        deck: [], 
        hand: [], 
        board: Array(4).fill(null),
        selectedCard: null,
        selectedAttacker: null
      },
      enemy: { 
        hp: 20, 
        mana: 1, 
        maxMana: 1, 
        board: Array(4).fill(null) 
      },
      turn: 'player',
      turnCount: 0
    };

    // Biblioth√®que de cartes
    const cardsLibrary = [
      { 
        id: 1,
        name: "Croco-Choc", 
        hp: 5, 
        atk: 3, 
        cost: 3, 
        effect: "Une cr√©ature redoutable avec des effets diff√©rents selon sa position",
        frontEffect: "Attaque l'ennemi avec 3 ATK",
        backEffect: "Donne +1 ATK √† toutes vos autres cr√©atures",
        frontLogic: (attacker, target) => basicAttack(attacker, target),
        backLogic: (card, board) => buffAllies(board, 1, 0)
      },
      { 
        id: 2,
        name: "Banane Boomerang", 
        hp: 2, 
        atk: 2, 
        cost: 2, 
        effect: "Une banane qui revient toujours vers son propri√©taire",
        frontEffect: "Inflige 2 d√©g√¢ts et pioche 1 carte",
        backEffect: "Soigne 1 PV √† votre joueur",
        frontLogic: (attacker, target) => {
          basicAttack(attacker, target);
          if (gameState.player.hand.length < 5) {
            drawCardToHand();
          }
        },
        backLogic: (card, board) => healPlayer(1)
      },
      { 
        id: 3,
        name: "Tralala Myst√®re", 
        hp: 1, 
        atk: 1, 
        cost: 1, 
        effect: "Personne ne sait ce qu'il va faire, pas m√™me lui !",
        frontEffect: "Effet al√©atoire: attaque, soin ou buff",
        backEffect: "Effet al√©atoire: soin, buff ou d√©g√¢ts",
        frontLogic: (attacker, target) => {
          const effects = [
            () => basicAttack(attacker, target),
            () => healPlayer(1),
            () => buffCard(attacker, 1, 1)
          ];
          effects[Math.floor(Math.random() * effects.length)]();
        },
        backLogic: (card, board) => {
          const effects = [
            () => healPlayer(1),
            () => buffAllies(board, 0, 1),
            () => damageEnemy(1)
          ];
          effects[Math.floor(Math.random() * effects.length)]();
        }
      },
      {
        id: 4,
        name: "Poulpe Pirate",
        hp: 4,
        atk: 2,
        cost: 4,
        effect: "Un poulpe avec un bandeau et un crochet",
        frontEffect: "Attaque deux fois de suite",
        backEffect: "Vole 1 mana √† l'ennemi",
        frontLogic: (attacker, target) => {
          basicAttack(attacker, target);
          basicAttack(attacker, target);
        },
        backLogic: (card, board) => {
          if (gameState.enemy.mana > 0) {
            gameState.enemy.mana--;
            gameState.player.mana++;
            updateUI();
          }
        }
      },
      {
        id: 5,
        name: "Mouton Nucl√©aire",
        hp: 6,
        atk: 1,
        cost: 5,
        effect: "Un mouton avec une aura radioactive",
        frontEffect: "Explose en infligeant 2 d√©g√¢ts √† toutes les cartes ennemies (d√©truit cette carte)",
        backEffect: "Donne +2 PV √† toutes vos autres cr√©atures",
        frontLogic: (attacker, target) => {
          // D√©g√¢ts √† toutes les cartes ennemies
          gameState.enemy.board.forEach((card, index) => {
            if (card) {
              card.hp -= 2;
              if (card.hp <= 0) {
                gameState.enemy.board[index] = null;
              }
            }
          });
          // D√©truit cette carte
          const slotIndex = gameState.player.board.indexOf(attacker);
          gameState.player.board[slotIndex] = null;
          renderBoard();
        },
        backLogic: (card, board) => buffAllies(board, 0, 2)
      }
    ];

    // Effets de base
    function basicAttack(attacker, target) {
      if (!target) {
        // Attaque directe du joueur
        gameState.enemy.hp -= attacker.atk;
        if (gameState.enemy.hp <= 0) endGame("Victoire !");
      } else {
        // Attaque une carte
        target.hp -= attacker.atk;
        if (target.hp <= 0) {
          const index = gameState.enemy.board.indexOf(target);
          gameState.enemy.board[index] = null;
        }
      }
      updateUI();
    }

    function buffAllies(board, atkBuff, hpBuff) {
      board.forEach(card => {
        if (card) {
          card.atk += atkBuff;
          card.hp += hpBuff;
        }
      });
    }

    function buffCard(card, atkBuff, hpBuff) {
      card.atk += atkBuff;
      card.hp += hpBuff;
    }

    function healPlayer(amount) {
      gameState.player.hp = Math.min(20, gameState.player.hp + amount);
      updateUI();
    }

    function damageEnemy(amount) {
      gameState.enemy.hp -= amount;
      if (gameState.enemy.hp <= 0) endGame("Victoire !");
      updateUI();
    }

    // Initialisation du jeu
    function initGame() {
      // Cr√©er un deck de 20 cartes (4 exemplaires de chaque)
      gameState.player.deck = [];
      for (let i = 0; i < 4; i++) {
        cardsLibrary.forEach(card => {
          gameState.player.deck.push({...card});
        });
      }
      
      // M√©langer le deck
      shuffleDeck(gameState.player.deck);
      
      // Pioche initiale
      for (let i = 0; i < 3; i++) {
        drawCardToHand();
      }
      
      updateUI();
      renderBoard();
      renderHand();
    }

    function shuffleDeck(deck) {
      for (let i = deck.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [deck[i], deck[j]] = [deck[j], deck[i]];
      }
    }

    function drawCardToHand() {
      if (gameState.player.hand.length >= 5) {
        alert("Votre main est pleine (5 cartes maximum)");
        return false;
      }
      if (gameState.player.deck.length === 0) {
        alert("Plus de cartes dans le deck !");
        return false;
      }
      gameState.player.hand.push(gameState.player.deck.pop());
      renderHand();
      return true;
    }

    function drawCard() {
      if (gameState.turn !== 'player') return;
      if (gameState.player.mana < 3) {
        alert("Pas assez de mana pour piocher (co√ªt: 3)");
        return;
      }
      gameState.player.mana -= 3;
      drawCardToHand();
      updateUI();
    }

    function selectCard(index) {
      if (gameState.turn !== 'player') return;
      
      // D√©s√©lectionner si on clique sur la m√™me carte
      if (gameState.player.selectedCard === index) {
        gameState.player.selectedCard = null;
        hideCardDetails();
        clearHighlights();
        renderHand();
        return;
      }
      
      gameState.player.selectedCard = index;
      showCardDetails(gameState.player.hand[index]);
      highlightAvailableSlots();
      renderHand();
    }

    function showCardDetails(card) {
      const detailsEl = document.getElementById('card-details');
      detailsEl.innerHTML = `
        <div class="card-details-name">${card.name}</div>
        <div class="card-details-stats">
          <div class="card-details-stat">
            <div>ATK</div>
            <div class="card-details-stat-value">${card.atk}</div>
          </div>
          <div class="card-details-stat">
            <div>HP</div>
            <div class="card-details-stat-value">${card.hp}</div>
          </div>
          <div class="card-details-stat">
            <div>CO√õT</div>
            <div class="card-details-stat-value">${card.cost}</div>
          </div>
        </div>
        <div class="card-details-effect">${card.effect}</div>
        <div class="position-effects">
          <div class="position-effect front">
            <h4>En Position Avant</h4>
            <div>${card.frontEffect}</div>
          </div>
          <div class="position-effect back">
            <h4>En Position Arri√®re</h4>
            <div>${card.backEffect}</div>
          </div>
        </div>
      `;
      detailsEl.classList.add('active');
    }

    function hideCardDetails() {
      document.getElementById('card-details').classList.remove('active');
    }

    function placeCard(slotIndex) {
      if (gameState.turn !== 'player') return;
      if (gameState.player.selectedCard === null) return;
      if (gameState.player.board[slotIndex] !== null) return;
      
      const card = gameState.player.hand[gameState.player.selectedCard];
      
      if (gameState.player.mana < card.cost) {
        alert("Pas assez de mana pour cette carte");
        return;
      }
      
      gameState.player.mana -= card.cost;
      gameState.player.board[slotIndex] = {...card};
      gameState.player.hand.splice(gameState.player.selectedCard, 1);
      
      gameState.player.selectedCard = null;
      hideCardDetails();
      clearHighlights();
      renderHand();
      renderBoard();
      updateUI();
    }

    function selectAttacker(slotIndex) {
      if (gameState.turn !== 'player') return;
      if (gameState.player.board[slotIndex] === null) return;
      
      gameState.player.selectedAttacker = slotIndex;
      highlightAttackTargets();
    }

    function highlightAttackTargets() {
      // R√©initialiser les highlights
      clearHighlights();
      
      // Mettre en √©vidence les cibles possibles
      gameState.enemy.board.forEach((slot, index) => {
        if (slot !== null) {
          document.getElementById('enemy-zone').children[index].classList.add('attackable');
        }
      });
      
      // Ajouter aussi le joueur ennemi comme cible
      document.getElementById('enemy-hp').parentElement.classList.add('attackable');
    }

    function attack(targetIndex) {
      if (gameState.turn !== 'player') return;
      if (gameState.player.selectedAttacker === null) return;
      
      const attacker = gameState.player.board[gameState.player.selectedAttacker];
      if (!attacker) return;
      
      let target = null;
      if (targetIndex !== undefined && targetIndex !== null) {
        target = gameState.enemy.board[targetIndex];
      }
      
      // D√©terminer la position de la carte (avant ou arri√®re)
      const position = gameState.player.selectedAttacker < 2 ? 'front' : 'back';
      
      // Appliquer l'effet selon la position
      if (position === 'front') {
        attacker.frontLogic(attacker, target);
      } else {
        attacker.backLogic(attacker, gameState.player.board);
      }
      
      gameState.player.selectedAttacker = null;
      clearHighlights();
      renderBoard();
      updateUI();
    }

    function highlightAvailableSlots() {
      // R√©initialiser les highlights
      clearHighlights();
      
      // Mettre en √©vidence les emplacements disponibles
      gameState.player.board.forEach((slot, index) => {
        if (slot === null) {
          document.getElementById('player-zone').children[index].classList.add('placeable');
        }
      });
    }

    function clearHighlights() {
      document.querySelectorAll('.highlight, .attackable, .placeable').forEach(el => {
        el.classList.remove('highlight', 'attackable', 'placeable');
      });
    }

    function endTurn() {
      if (gameState.turn !== 'player') return;
      
      // Appliquer les effets de fin de tour pour les cartes en arri√®re
      gameState.player.board.forEach((card, index) => {
        if (card && index >= 2) { // Cartes en arri√®re
          card.backLogic(card, gameState.player.board);
        }
      });
      
      // Passer au tour de l'ennemi
      gameState.turn = 'enemy';
      document.getElementById('turn-indicator').textContent = "TOUR DE L'ENNEMI";
      document.getElementById('turn-indicator').className = 'turn-indicator enemy-turn';
      
      // Augmenter le mana max si besoin
      if (gameState.enemy.maxMana < 10) {
        gameState.enemy.maxMana++;
      }
      gameState.enemy.mana = gameState.enemy.maxMana;
      
      updateUI();
      
      // L'IA joue apr√®s un court d√©lai
      setTimeout(enemyTurn, 1000);
    }

    function enemyTurn() {
      // L'IA simple :
      // 1. Pioche si possible (33% de chance)
      if (Math.random() < 0.33 && gameState.enemy.mana >= 3) {
        gameState.enemy.mana -= 3;
        // L'IA a un deck infini pour simplifier
      }
      
      // 2. Pose des cartes al√©atoirement
      const playableCards = [
        {id: 1, cost: 3}, // Croco-Choc
        {id: 2, cost: 2}, // Banane Boomerang
        {id: 3, cost: 1}  // Tralala Myst√®re
      ];
      
      while (gameState.enemy.mana > 0) {
        const availableSlots = [];
        gameState.enemy.board.forEach((slot, index) => {
          if (slot === null) availableSlots.push(index);
        });
        
        if (availableSlots.length === 0) break;
        
        const randomCard = playableCards[Math.floor(Math.random() * playableCards.length)];
        if (gameState.enemy.mana >= randomCard.cost) {
          const slotIndex = availableSlots[Math.floor(Math.random() * availableSlots.length)];
          gameState.enemy.board[slotIndex] = {
            ...cardsLibrary.find(c => c.id === randomCard.id)
          };
          gameState.enemy.mana -= randomCard.cost;
        } else {
          break;
        }
      }
      
      // 3. Attaque avec les cartes
      gameState.enemy.board.forEach((card, index) => {
        if (card) {
          // 50% de chance d'attaquer avec chaque carte
          if (Math.random() < 0.5) {
            const position = index < 2 ? 'front' : 'back';
            if (position === 'front') {
              // Choisir une cible al√©atoire
              const playerCards = gameState.player.board.filter(c => c !== null);
              if (playerCards.length > 0) {
                const target = playerCards[Math.floor(Math.random() * playerCards.length)];
                card.frontLogic(card, target);
              } else {
                // Attaque directe
                card.frontLogic(card, null);
              }
            } else {
              card.backLogic(card, gameState.enemy.board);
            }
          }
        }
      });
      
      renderBoard();
      updateUI();
      
      // Fin du tour de l'ennemi
      setTimeout(() => {
        startPlayerTurn();
      }, 1000);
    }

    function startPlayerTurn() {
      gameState.turn = 'player';
      document.getElementById('turn-indicator').textContent = "VOTRE TOUR";
      document.getElementById('turn-indicator').className = 'turn-indicator player-turn';
      
      // Augmenter le mana max si besoin
      if (gameState.player.maxMana < 10) {
        gameState.player.maxMana++;
      }
      gameState.player.mana = gameState.player.maxMana;
      
      // Pioche automatique en d√©but de tour
      if (gameState.player.hand.length < 5 && gameState.player.deck.length > 0) {
        drawCardToHand();
      }
      
      updateUI();
    }

    function endGame(message) {
      alert(message);
      // R√©initialiser le jeu
      gameState.player = { 
        hp: 20, 
        mana: 1, 
        maxMana: 1, 
        deck: [], 
        hand: [], 
        board: Array(4).fill(null),
        selectedCard: null,
        selectedAttacker: null
      };
      gameState.enemy = { 
        hp: 20, 
        mana: 1, 
        maxMana: 1, 
        board: Array(4).fill(null) 
      };
      gameState.turn = 'player';
      initGame();
    }

    function renderBoard() {
      renderZone('player-zone', gameState.player.board, 'ally');
      renderZone('enemy-zone', gameState.enemy.board, 'enemy');
    }

    function renderZone(zoneId, board, type) {
      const zone = document.getElementById(zoneId);
      zone.innerHTML = '';
      
      board.forEach((card, index) => {
        const slot = document.createElement('div');
        slot.className = `slot ${type}`;
        
        if (card) {
          const cardEl = document.createElement('div');
          cardEl.className = 'card';
          cardEl.innerHTML = `
            <div class="mana-cost">${card.cost}</div>
            <div class="card-name">${card.name}</div>
            <div class="card-stats">
              <div class="card-stat">
                <div>ATK</div>
                <div class="card-stat-value">${card.atk}</div>
              </div>
              <div class="card-stat">
                <div>HP</div>
                <div class="card-stat-value">${card.hp}</div>
              </div>
            </div>
            <div class="card-effect">${card.effect}</div>
            <div class="hp-bar">
              <div class="hp-bar-fill" style="width: ${(card.hp / (card.hp + 5)) * 100}%"></div>
            </div>
          `;
          
          if (type === 'ally' && gameState.turn === 'player') {
            slot.onclick = () => {
              if (gameState.player.selectedAttacker !== null) {
                // Annuler la s√©lection si on clique sur la m√™me carte
                if (gameState.player.selectedAttacker === index) {
                  gameState.player.selectedAttacker = null;
                  clearHighlights();
                }
              } else {
                selectAttacker(index);
              }
            };
          }
          
          slot.appendChild(cardEl);
        } else if (type === 'ally' && gameState.turn === 'player') {
          slot.onclick = () => {
            if (gameState.player.selectedCard !== null) {
              placeCard(index);
            }
          };
        } else if (type === 'enemy' && gameState.player.selectedAttacker !== null && gameState.turn === 'player') {
          slot.onclick = () => {
            attack(index);
          };
        }
        
        zone.appendChild(slot);
      });
      
      // Ajouter la possibilit√© d'attaquer directement le joueur
      if (type === 'enemy' && gameState.player.selectedAttacker !== null && gameState.turn === 'player') {
        const enemyHpEl = document.getElementById('enemy-hp').parentElement;
        enemyHpEl.onclick = () => {
          attack(null); // Attaque directe
        };
      }
    }

    function renderHand() {
      const handEl = document.getElementById('hand');
      handEl.innerHTML = '';
      
      gameState.player.hand.forEach((card, index) => {
        const cardEl = document.createElement('div');
        cardEl.className = 'card hand-card';
        if (gameState.player.selectedCard === index) {
          cardEl.classList.add('selected-card');
        }
        cardEl.innerHTML = `
          <div class="mana-cost">${card.cost}</div>
          <div class="card-name">${card.name}</div>
          <div class="card-stats">
            <div class="card-stat">
              <div>ATK</div>
              <div class="card-stat-value">${card.atk}</div>
            </div>
            <div class="card-stat">
              <div>HP</div>
              <div class="card-stat-value">${card.hp}</div>
            </div>
          </div>
        `;
        
        cardEl.onclick = () => selectCard(index);
        handEl.appendChild(cardEl);
      });
    }

    function updateUI() {
      document.getElementById('player-hp').textContent = gameState.player.hp;
      document.getElementById('enemy-hp').textContent = gameState.enemy.hp;
      document.getElementById('player-mana').textContent = gameState.player.mana;
      document.getElementById('enemy-mana').textContent = gameState.enemy.mana;
      
      // D√©sactiver le bouton pioche si pas assez de mana
      document.getElementById('draw-btn').disabled = gameState.player.mana < 3 || gameState.turn !== 'player';
    }

    // D√©marrer le jeu
    initGame();
    
    // Service Worker registration
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('sw.js')
          .then(registration => {
            console.log('ServiceWorker registration successful');
          })
          .catch(err => {
            console.log('ServiceWorker registration failed: ', err);
          });
      });
    }
  </script>
</body>
</html>
